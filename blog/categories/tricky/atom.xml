<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tricky | 亨利的博客]]></title>
  <link href="http:///blog/categories/tricky/atom.xml" rel="self"/>
  <link href="http:///"/>
  <updated>2017-10-03T00:30:57+08:00</updated>
  <id>http:///</id>
  <author>
    <name><![CDATA[Henry]]></name>
    <email><![CDATA[hwguo1988@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux下查看系统空闲内存的方法]]></title>
    <link href="http:///blog/2015/05/31/linux-freemem/"/>
    <updated>2015-05-31T23:00:42+08:00</updated>
    <id>http:///blog/2015/05/31/linux-freemem</id>
    <content type="html"><![CDATA[<h2>1. free</h2>

<p>linux系统中，查看当前内存的使用情况，简便的方法是free命令，命令行中free -m，列出系统当前的可用内存、cache/buffer、swap相关信息。</p>

<p>free工具是procps项目提供的标准proc文件系统分析工具，通过读取分析/proc/meminfo，实时的反应当前系统的内存使用情况。项目主页：<a href="http://procps.sourceforge.net">procps.sourceforge.net</a></p>

<p><img src="http://pic.yupoo.com/taingg/EH1ELm9n/vG6TW.png" alt="free" /></p>

<!--more-->


<h2>2. 用户态程序中，利用sysinfo系统调用</h2>

<p>如果想在程序中实时查看系统当前可用内存情况，可以利用的方法也是多样的。</p>

<p>1.如果是在用户态程序中查看，可以通过“system”系统调用，执行free命令，或是读取/proc/meminfo文件，再做文本处理。</p>

<p>2.当然1的方法不够直观，/proc/meminfo中的信息是系统利用proc文件系统的处理函数获得的，内核代码fs/proc/meminfo.c中实现的。
粗读代码可以发现struct sysinfo这个结构（include/linux/kernel.h中定义）</p>

<pre><code>struct sysinfo {
         long uptime;                    /* Seconds since boot */
         unsigned long loads[3];         /* 1, 5, and 15 minute load averages */
         unsigned long totalram;         /* Total usable main memory size */
         unsigned long freeram;          /* Available memory size */
         unsigned long sharedram;        /* Amount of shared memory */
         unsigned long bufferram;        /* Memory used by buffers */
         unsigned long totalswap;        /* Total swap space size */
         unsigned long freeswap;         /* swap space still available */
         unsigned short procs;           /* Number of current processes */
         unsigned short pad;             /* explicit padding for m68k */
         unsigned long totalhigh;        /* Total high memory size */
         unsigned long freehigh;         /* Available high memory size */
         unsigned int mem_unit;          /* Memory unit size in bytes */
         char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding: libc5 uses this.. */
};
</code></pre>

<p>可以看到该结构中定义了系统的内存使用情况。源码中查询sysinfo，发现有sysinfo这个系统调用，用于查询和获得系统信息。于是在用户态程序中可以采用如下方法：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/kernel.h&gt;

int main()
{
    struct sysinfo sys_i;
    int err = sysinfo(&amp;sys_i);
    printf("\n\nerror code is: %d\n", err);

    printf( "free mem:\t%ld\n"                                                                               
            "total mem:\t%ld\n"
            "buffer mem:\t%ld\n", 
            sys_i.freeram, sys_i.totalram, sys_i.bufferram 
          );  

    return 0;
}
</code></pre>

<p>编译并执行：</p>

<p>~$ <strong><em>gcc -o play test.c</em></strong></p>

<p>对比执行结果与free的结果：
<img src="http://pic.yupoo.com/taingg/EH1SEQsN/xF8zK.png" alt="sysinfo与free对比" /></p>

<h2>3. 内核态程序中，利用do_sysinfo中的si_meminfo实现</h2>

<p>在内核态中实现，我没有找到很好的方法。通过读代码，找到执行sysinfo系统调用的回调函数sys_sysinfo</p>

<pre><code>SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
</code></pre>

<p>进一步宏展开SYSCALL_DEFINE1得到验证:</p>

<pre><code>SYSCALL_DEFINE1(sysinfo, struct sysinfo __user *, info)
{
         struct sysinfo val;

         do_sysinfo(&amp;val);

         if (copy_to_user(info, &amp;val, sizeof(struct sysinfo)))
                 return -EFAULT;

         return 0;
}
</code></pre>

<p>核心实现函数为do_sysinfo函数，该函数执行内容过多，为免除不必要操作，只利用与freeram相关的函数操作，即：si_meminfo函数。</p>

<pre><code>void si_meminfo(struct sysinfo *val)
{
         val-&gt;totalram = totalram_pages;
         val-&gt;sharedram = 0;
         val-&gt;freeram = global_page_state(NR_FREE_PAGES);
         val-&gt;bufferram = nr_blockdev_pages();
         val-&gt;totalhigh = totalhigh_pages;
         val-&gt;freehigh = nr_free_highpages();
         val-&gt;mem_unit = PAGE_SIZE;
}
</code></pre>

<p>可以看到，sysinfo中的ram相关内容被赋值。写一个内核模块做测试:</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;asm/page.h&gt;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("GuoHongwei");

static int sysinfo_init()
{
    struct sysinfo sys;
    // int err = do_sysinfo(&amp;sys);

    si_meminfo(&amp;sys);

    // printk("\n\nerror code is: %ld", err);
    printk("free mem is: %ld\n", (sys.freeram &lt;&lt; (PAGE_SHIFT - 10)));

    return 0;
}

static void sysinfo_exit()
{
    printk("exit module sysinfo_test\n");
}

module_init(sysinfo_init);
module_exit(sysinfo_exit);

Makefile：
obj-m := sysinfo_test.o
KERNELDIR = /lib/modules/$(shell uname -r)/build                                                             
PWD := $(shell pwd)

default:
        make -C $(KERNELDIR) M=$(PWD) modules

clean:
        make -C $(KERNELDIR) M=$(PWD) clean
</code></pre>

<p>执行结果如下：</p>

<p><img src="http://pic.yupoo.com/taingg/EH1UAbNv/zQZ0M.png" alt="si_meminfo" /></p>
]]></content>
  </entry>
  
</feed>
